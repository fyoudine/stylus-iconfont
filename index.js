// Generated by CoffeeScript 1.12.3
var FontFactory, Q, fs, nodes, path, stylus, svg2ttf, svgicons2svgfont, ttf2eot, ttf2woff, utils, vendorDownloader,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

stylus = require('stylus');

path = require('path');

fs = require('fs');

Q = require('q');

svgicons2svgfont = require('svgicons2svgfont');

svg2ttf = require('svg2ttf');

ttf2eot = require('ttf2eot');

ttf2woff = require('ttf2woff');

nodes = stylus.nodes;

utils = stylus.utils;

vendorDownloader = require('./download');

FontFactory = (function() {
  var writeEotFile, writeTtfFile, writeWoffFile;

  function FontFactory(options) {
    this.writeFiles = bind(this.writeFiles, this);
    this.updateVendorPrefix = bind(this.updateVendorPrefix, this);
    this.collectGlyphsNames = bind(this.collectGlyphsNames, this);
    this.run = bind(this.run, this);
    this.checkVendorDownloads = bind(this.checkVendorDownloads, this);
    this.fontFace = bind(this.fontFace, this);
    this.register = bind(this.register, this);
    this.options = this.updateOptions(options);
    this.vendorMapping = {
      'fa': {
        path: "downloads/fontAwesome",
        name: "Font Awesome"
      }
    };
    if (this.options.autoDownloadVendor) {
      this.checkVendorDownloads(this.options);
    }
    this.startIndex = 0xF700;
    this.glyphsNames = [];
    this.glyphsInFont = [];
    this.allDone = [];
  }

  FontFactory.prototype.register = function(style) {
    style.define('icon-font-name', new stylus.nodes.String(this.options.fontName));
    style.define('icon-font-unicode', this.collectGlyphsNames);
    style.define('icon-font-font-face', this.fontFace(this.options));
    style.include(__dirname);
  };

  FontFactory.prototype.fontFace = function(options) {
    var pathToFont;
    pathToFont = (options.fontFacePath.replace(/\/$/, '')) + "/" + options.fontName;
    return function() {
      var lit;
      lit = new nodes.Literal("@font-face {\n  font-family: '" + options.fontName + "';\n  src: url('" + pathToFont + ".eot');\n  src: url('" + pathToFont + ".eot') format('embedded-opentype'), url('" + pathToFont + ".woff') format('woff'), url('" + pathToFont + ".ttf') format('truetype'), url('" + pathToFont + ".svg') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}");
      lit.filename = "iconfont-autogenerated.styl";
      return lit;
    };
  };

  writeEotFile = function(ttfBuffer, outputFile, log) {
    var eot, eotBuffer;
    eot = ttf2eot(new Uint8Array(ttfBuffer));
    eotBuffer = new Buffer(eot.buffer);
    fs.writeFileSync(outputFile + ".eot", eotBuffer);
    return typeof log === "function" ? log("[icon-font]: EOT font file created") : void 0;
  };

  writeWoffFile = function(ttfBuffer, outputFile, log) {
    var woff, woffBuffer;
    woff = ttf2woff(new Uint8Array(ttfBuffer));
    woffBuffer = new Buffer(woff.buffer);
    fs.writeFileSync(outputFile + ".woff", woffBuffer);
    return typeof log === "function" ? log("[icon-font]: WOFF font file created") : void 0;
  };

  writeTtfFile = function(ttfBuffer, outputFile, log) {
    fs.writeFileSync(outputFile + ".ttf", ttfBuffer);
    return typeof log === "function" ? log("[icon-font]: TTF font file created") : void 0;
  };

  FontFactory.prototype.checkVendorDownloads = function() {
    var base, base1, key, ref, results, val;
    if (typeof (base = this.options).log === "function") {
      base.log("[icon-font]: checking vendor downloads");
    }
    ref = this.vendorMapping;
    results = [];
    for (key in ref) {
      val = ref[key];
      if (fs.existsSync(this.options.glyphsDir + "/" + val.path)) {
        this.vendorMapping[key].downloaded = true;
        results.push(typeof (base1 = this.options).log === "function" ? base1.log("[icon-font]: " + val.name + " found in '" + this.options.glyphsDir + "/" + val.path + "'") : void 0);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  FontFactory.prototype.run = function() {
    var i, index, item, len, name, ref;
    this.allDone = [];
    ref = this.glyphsNames;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      name = ref[index];
      item = {
        codepoint: this.startIndex + index,
        name: name,
        path: this.options.glyphsDir + "/" + name + ".svg"
      };
      if (this.options.autoDownloadVendor) {
        item = this.updateVendorPrefix(item);
        if (item === false) {
          continue;
        }
      }
      this.allDone.push(Q(item));
    }
    this.glyphsNames = [];
    return Q.all(this.allDone).then((function(_this) {
      return function(result) {
        var base;
        if (result.length) {
          if (typeof (base = _this.options).log === "function") {
            base.log("[icon-font]: Starting Write font Files");
          }
          path = "" + (_this.options.outputDir.replace(/\/$/, ''));
          _this.writeFiles(result, path, "" + _this.options.fontName);
        }
      };
    })(this));
  };

  FontFactory.prototype.updateOptions = function(options) {
    options = options || {};

    /*
       svgicons2svgfont(options)
     */
    if (options.fontName == null) {
      options.fontName = 'iconfont';
    }
    if (options.fixedWidth == null) {
      options.fixedWidth = false;
    }
    if (options.centerHorizontally == null) {
      options.centerHorizontally = false;
    }
    if (options.normalize == null) {
      options.normalize = true;
    }
    if (options.descent == null) {
      options.descent = 0;
    }
    if (options.log == null) {
      options.log = false;
    }

    /*
       iconFont(options)
     */
    if (options.glyphsDir == null) {
      options.glyphsDir = process.cwd();
    }
    if (options.outputDir == null) {
      options.outputDir = process.cwd();
    }
    if (options.fontFacePath == null) {
      options.fontFacePath = "/";
    }
    if (options.watchMode == null) {
      options.watchMode = true;
    }
    if (options.autoDownloadVendor == null) {
      options.autoDownloadVendor = true;
    }
    if (options.outputTypes == null) {
      options.outputTypes = ['svg', 'ttf', 'eot', 'woff'];
    }
    return options;
  };

  FontFactory.prototype.collectGlyphsNames = function(name) {
    var index, lit;
    index = this.glyphsNames.indexOf(name.string);
    if (index < 0) {
      index = this.glyphsNames.push(name.string);
    }
    lit = new nodes.Literal(name.quote + "\\" + ((this.startIndex + this.glyphsNames.indexOf(name.string)).toString(16)) + name.quote);
    lit.filename = "iconfont-autogenerated.styl";
    return lit;
  };

  FontFactory.prototype.updateVendorPrefix = function(item) {
    var deferred, segments;
    segments = item.name.split("/");
    if (segments.length > 1 && this.vendorMapping.hasOwnProperty(segments[0])) {
      item.path = this.options.glyphsDir + "/" + this.vendorMapping[segments[0]].path + "/" + (segments.slice(1).join("-")) + ".svg";
      if (this.vendorMapping[segments[0]].downloaded != null) {
        return item;
      } else {
        deferred = Q.defer();
        this.allDone.push(deferred.promise);
        if (this.vendorMapping[segments[0]].delayed == null) {
          this.vendorMapping[segments[0]].delayed = [];
        }
        this.vendorMapping[segments[0]].delayed.push(function() {
          return deferred.resolve(item);
        });
        if (!this.vendorMapping[segments[0]].downloading && !this.vendorMapping[segments[0]].downloaded) {
          this.vendorMapping[segments[0]].downloading = true;
          vendorDownloader(segments[0], this.options.glyphsDir + "/" + this.vendorMapping[segments[0]].path).then((function(_this) {
            return function() {
              var func, i, len, ref;
              _this.vendorMapping[segments[0]].downloading = false;
              _this.vendorMapping[segments[0]].downloaded = true;
              ref = _this.vendorMapping[segments[0]].delayed;
              for (i = 0, len = ref.length; i < len; i++) {
                func = ref[i];
                func();
              }
            };
          })(this));
        }
        return false;
      }
    } else {
      return item;
    }
  };

  FontFactory.prototype.writeFiles = function(glyphs, path, fontName) {
    var base, fontStream, glyph, i, index, len, needToUpdate, outputFile, ref;
    needToUpdate = false;
    for (index = i = 0, len = glyphs.length; i < len; index = ++i) {
      glyph = glyphs[index];
      if (!fs.existsSync(glyph.path)) {
        this.options.log("[icon-font]: File not found '" + glyph.path + "'");
        glyphs.splice(index, 1);
      } else {
        if (ref = glyph.name, indexOf.call(this.glyphsInFont, ref) < 0) {
          this.glyphsInFont.push(glyph.name);
          needToUpdate = true;
        }
        glyph.stream = fs.createReadStream("" + glyph.path);
      }
    }
    if (!needToUpdate) {
      if (typeof (base = this.options).log === "function") {
        base.log("[icon-font]: Nothing to update");
      }
      return;
    } else {
      this.glyphsNames = this.glyphsInFont.slice();
    }
    outputFile = path + "/" + fontName;
    fontStream = svgicons2svgfont(glyphs, this.options).pipe(fs.createWriteStream(outputFile + ".svg")).on('finish', (function(_this) {
      return function() {
        var base1, ttf, ttfBuffer;
        if (typeof (base1 = _this.options).log === "function") {
          base1.log("[icon-font]: SVG font file created");
        }
        ttf = svg2ttf(fs.readFileSync(outputFile + ".svg", {
          encoding: "utf8"
        }), {});
        ttfBuffer = new Buffer(ttf.buffer);
        if (indexOf.call(_this.options.outputTypes, 'ttf') >= 0) {
          writeTtfFile(ttfBuffer, outputFile, _this.options.log);
        }
        if (indexOf.call(_this.options.outputTypes, 'woff') >= 0) {
          writeWoffFile(ttfBuffer, outputFile, _this.options.log);
        }
        if (indexOf.call(_this.options.outputTypes, 'eot') >= 0) {
          return writeEotFile(ttfBuffer, outputFile, _this.options.log);
        }
      };
    })(this));
  };

  return FontFactory;

})();

module.exports = FontFactory;

module.exports.version = require(path.join(__dirname, 'package.json')).version;

module.exports.path = __dirname;
